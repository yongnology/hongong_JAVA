--------------------------------------------------
chapter 01 자바 시작하기
--------------------------------------------------

01-1 프로그래밍 언어와 자바

프로그리밍 언어로 작성한 파일을 소스(sourc) 파일이라고 한다.
소스 파일은 컴퓨터가 바로 이해할 수 없기 떄문에 컴파일(compile)과정을 통해서 0과 1로 이루어진
기계어로 번역한 후에 컴퓨터에서 사용한다.

자바의 특징
- 모든 운영체제에서 실행 가능하다.
- 객체 지향 프로그래밍
- 메모리 작동 정리
- 무료 라이브러리 풍부

자바 개발 도구 설치
- 자바 개발 도구(JDK : Java Development Kit) 설치를 해야한다.
- java jdk 11.0.13 다운
- JDK가 설치된 폴더(C:\Program Files\java\jdk-11.0.13)을 일반적으로 JAVA_HOME이라고 한다.
	JAVA_HOME 환경 변수를 만들고 JDK 설치 폴더를 등록하는 것이 좋다.
- 실행 방법 : 시작 - 제어판 - 시스템 및 보안 - 시스템 - 고급 시스템 설정

변수이름 : JAVA_HOME
변수 값 : JDK 설치 경로( 보통 C:\Program Files\java\jdk **.**.** )

시스템 변수 중
path 편집 - 새로만들기
%JAVA_HOME%bin
맨 위로 이동 후 확인.

6가지 키워드로 끝내는 핵심 포인트
- 기계어 : 컴퓨터(운영체제)가 이해하고 실행할 수 있는 0과 1로 이루어진 코드
- 프로그래밍 언어 : 사람이 기계어를 이해하는 것은 매우 어렵기 때문에 사람의 언어와
	기계어의 다리 역할을 한다. 종류로는 C, C++, JAVA, Python 등이 있다.
- 소스 파일 : 프로그래밍 언어로 작성된 파일.
- 컴파일 : 소스파일을 기계어로 번역하는 것. 이 역할을 담당하는 소프트웨어를 컴파일러라고 한다.
- JDK : 자바 개발 도구(Java Developmnet Kit) 자바로 프로그램을 개발할 수 있는 실행 환경(JVM)과
	개발 도구(컴파일러) 등을 제공한다.

--------------------------------------------------

01-2 이클립스 개발 환경 구축

이클립스는 무료로 사용할 수 있는 오픈 소스 통합 개발 환경(IDE : Integrated Development Environmnet)
https://www.eclipse.org 에서 다운로드 할 수 있다.

이클립스 초기화 방법
Workspace 로 지정된 폴더를 열어보면 .metadata 폴더가 있다.
만약 초기 상태로 돌아가고 싶으면 .metadata 폴더를 강제 삭제 후 재시작하면 된다.

4가지 키워드로 끝내는 핵심 포인트
- 이클립스
  : 무료로 사용할 수 있는 오픈 소스 통합 개발 환경(IDE : Integrated Development Environment).
  : IDE란 프로젝트 생성, 자동 코드 완성, 디버킹 등과 같이 개발에 필요한 여러 가지 기능을 통합적으로
    제공해주는 툴을 말한다.
- 워크스페이스
  : 이클립스 실행과 관련된 메타 데이터(metadata)와 프로젝트 폴더가 저장되는 폴더를 말한다.
- 뷰
  : 이클립스 내부에서 사용되는 작은 창을 말한다.
- 퍼스펙티브
  : 프로젝트를 개발할 때 유용하게 사용할 수 있는 뷰(view)들을 미리 묶어 이름을 붙여 놓은 것.

--------------------------------------------------

01-3 자바 프로그램 개발 과정

자바 프로그램은 완전한 기계어가 아닌,
바이트 코드(byte code) 파일(.class)로 구성된다.
바이트 코드 파일은 운영체제에서 바로 실행할 수 없고,
자바 가상 기계(JVM)라는 번역기가 필요하다.

public class Hello { 
					}

public class Hello : 클래스 선언부
Hello : 클래스 이름

중괄호 {}블록의 앞부분
public static void main(String[] args)를 메소드 선언부
괄호 () 바로 앞 main은 메소드 이름
java 명령어로 바이트 코드 파일을 실행하면
제일 먼저 main() 메소드를 찾아 블록 내부를 실행한다.
그래서 main()메소드를 프로그램 실행 진입점(entry point)라고 부른다.

주석
라인 주석 //
범위 주석 /*  */
도큐먼트 주석 /**  */
※ 주석 기호는 문자열(" ")내부에서는 작성할 수 없다.

세미콜론
실행문 끝에는 반드시 세미콜론(;)을 붙여서 실행문이 끝났음을 표시해 주어야 한다.

6가지 키워드로 끝내는 핵심 포인트
- 바이트 코드 파일
  : 자바 소스 파일을 javac 명령어로 컴파일한 파일을 말한다.
- JVM
  : 자바 가상 기계(Java Virtyal Machine)는 바이트 코드 파일을 운영체제를 위한 완전한 기계어로
    번역하고 실행한느 역할을 한다. JVM은 java명령어에 의해 구동된다.
- 클래스 선언
  : 자바 소스 파일은 클래스 선언부와 클래스 블록으로 구성된다. 이렇게 작성하는 것을 클래스 선언이라고 한다.
- main() 메소드
  : java 명령어로 바이트 코드 파일을 실행하면 제일 먼저 main() 메소드를 찾아 블록 내부를 실행한다.
    그래서 main() 메소드를 프로그램 실행 진입점(entry point)이라고 부른다.
- 주석
 : 주석은 프로그램 실행과는 상관없이 코드에 설명을 붙인 것을 말한다.
   주석은 컴파일 과정에서 무시되고 실행문만 바이트 코드로 번역된다.
- 실행문
  : 변수 선언, 값 저장, 메소드 호출에 해당하는 코드를 말한다.
    실행문 끝에는 세미콜론(;)을 붙여야 한다.

--------------------------------------------------
chapter 02 변수와 타입
--------------------------------------------------

02-1 변수

4가지 키워드로 끝내는 핵심 포인트
- 변수
  : 값을 저장할 수 있는 메모리 번지에 붙인 이름.
    변수를 통해 프로그램은 메모리 번지에 값을 저장하고 읽을 수 있다.
- 변수 선언
  : 변수에 어떤 타입의 데이터르 저장할지 그리고 변수 이름이 무엇인지를 결정하는 것
- 변수 사용
  : 변수의 값을 읽거나 변경하는 것을 말한다.
    변수는 출력문이나 연산식 내부에서 사용되어 변수에 저장된 값을 출력하거나 여산에 사용한다.
- 변수 사용 범위
  : 변수는 자신이 선언된 위치에서 자신이 속한 블록 내부까지만 사용이 가능하다.

--------------------------------------------------

02-2 기본타입

자바는 정수, 실수, 논리값을 저장할 수 있는 기본(primitive)타입을 제공한다.
정수 타입 : byte, char, short, int, long
실수 타입 : float, double
논리 타입 : boolean

char 타입은 음수 값을 가질 수 없다.

소스 코드에서 프로그래머에 의해 직접 입력된 값을 리터럴(literal)이라고 부른다.

ex) char에 대해
char var1 = 'A';
int var2 = 'A;
System.out.println(var1);	//A를 출력
System.out.println(var2);	//65를 출력

\ 를 이스케이프 문자 라고 부른다.

자주 사용하는 이스케이프 문자
\t : 탭만큼 띄움
\n : 줄 바꿈(라인 피드)
\r : 캐리지리턴
\" : " 출력
\' : ' 출력
\\ : \출력
\u16진수 : 16진수 유니코드에 해당하는 문자 출력

5가지 키워드로 끝내는 핵심 포인트
- 정수 타입
  : 정수를 저장할 수 있는 타입으로, byte, short, int, long 타입을 말한다.
- char 타입
  : 작은따옴표(')로 감싼 하나의 문자 리터럴을 저장할 수 있는 타입이다.
- String 타입
  : 큰따옴표(")로 감싼 문자열을 저장할 수 있는 타입이다.
- 실수 타입
  : 실수를 저장할 수 있는 타입으로 float, double 타입을 말한다.
- boolean 타입
  : 참과 거짓을 의미하는 true와 false를 저장할 수 있는 타입이다.

--------------------------------------------------
02-3 타입변환

자바에서 + 연산자는 두 가지 기능을 가지고 있다.
1) 덧셈, 2) 문자열 결합연산

ex 1) int value = 1+2+3		// 6출력
ex 2) String str = 1+"2"+"3" 	// 123출력

5가지 키워드로 끝내는 핵심 포인트
- 자동 타입 변환
  : 자동으로 타입이 변환되는 것을 의미.
    값의 허용 범위가 작은 타입이 허용 범위가 큰 타입으로 저장될 때 발생
- 강제 타입 변환 
  : 강제로 타입을 변환하는 것을 말한다.
    값의 허용 범위가 큰 타입을 허용 범위가 작은 타입으로 쪼개어서 저장하는 것을 의미
- 문자열 결합 연산
  : 문자열과 + 연산을 하면 다른 피연산자도 문자열로 저장되어 문자열 결합이 일어난다.
- Interger.parselnt()
  : 문자열을 정수 int 타입으로 변환한다.
- Double.parseDouble()
  : 문자열을 실수 double 타입으로 변환한다.

--------------------------------------------------

02-4 변수와 시스템 입출력

모니터 출력
System.out.println("출력 내용');

입력
System.in.read();

자주 사용되는 형식 문자열
정수
%d		: 정수
%6d		: 6자리 정수, 왼쪽 빈 자리 공백
%-6d		: 6자리 정수, 오른쪽 빈 자리 공백
%06d		: 6자리 정수, 왼쪽 빈 자리 0으로 채움

실수
%10.2f	: 소수점 이상 7자리, 소수점 이하 2자리. 왼쪽 빈 자리 공백
%-10.2f	: 소수점 이상 7자리, 소수점 이하 2자리. 오른쪽 빈 자리 공백
%010.2f	: 소수점 이상 7자리, 소수점 이하 2자리. 왼쪽 빈 자리 0채움

문자열
%s		: 문자열
%6s		: 6자리 문자열. 왼쪽 빈 자리 공백
%-6s		: 6자리 문자열. 오른쪽 빈 자리 공백

특수문자
\t 		: 탭(tab)
\n		: 줄 바꿈
%%		: %

5가지 키워드로 끝내는 핵심 포인트
- System.out.println()
  : 괄호에 주어진 매개값을 모니터로 출력하고 개행을 한다.
- System.out.print()
  : 괄호에 주어진 매개값을 모니터로 출력만 하고 개행하지 않는다.
- System.out.printf()
  : 괄호에 주어진 형식대로 출력한다.
- System.in.read()
  : 키보드에서 입력된 키코드를 읽는다.
- Scanner
  : System.in.read()는 키코드를 하나씩 읽기 때문에 2개 이상의 키가 조합된 한글을 읽을 수 없다.
키보드로부터 입력된 내용을 통 문자열로 읽기 위해서는 Scanner를 사용할 수 있다.

--------------------------------------------------
chaper 03 연산자
--------------------------------------------------

03-1 연산자와 연산식

연산자(Operator) 
  : 연산에 사용되는 표시나 기호
피연산자(Operand)
  : 연산자와 함꼐 연산되는 데이터
연산식(Expression)
  : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

4가지 키워드로 끝내는 핵심 포인트
- 연산자
  : 연산의 종류를 결정짓는 기호를 말한다. 연산자의 종류는 산술(+, -, *, /, %),
    증감(++, --), 비교(==, !=, ···), 논리(&&, ||, ···), 대입(=, +=, =+, ···)등이 있다.
- 피연산자
  : 연산식에서 연산되는 데이터(값)을 말한다.
    예를 들어, 연산식 3 + x에서 3과 변수x가 피연산자이다.
- 연산 방향
  : 연산식에서 같은 종류의 d녀산자가 여러 개 사용 될 경우 왼쪽에서 오른쪽으로,
    또는 오른쪽에서 왼쪽으로 연산되는 방향이 있다. 대부분의 연산자는 왼쪽에서 오른쪽으로 연산이 되지만,
    증감(++, --)과 대입(=, +=, -=)은 오른쪽에서 왼쪽으로 연산된다.
- 연산 우선순위
  : 서로 다른 연산자들이 복합적으로 구성되면 우선적으로 연산되는 연산자가 있다.
    하지만 괄호 ()로 감산 연산이 최우선순위를 갖기 떄문에 복잡한 연산식에서 연산의 순서를
    정하고 싶을 때에는 괄호() 를 사용한다.

--------------------------------------------------

03-2 연산자의 종류

5가지 키워드로 끝내는 핵심 포인트
- 증감 연산자
  : ++, --를 말하며 변수의 값을 1씩 증가, 1씩 감소시킨다.
- 비교 연산자
  : ==, != 등을 말하며 값이 같은지, 다른지를 비교하고 boolean 값을 산출한다.
- 논리 연산자
  : &&, ||, ! 등을 말하며 논리곱, 논리합, 논리 부정을 수행하고 boolean 값을 산출한다.
- 대입 연산자
  : =, +=, -=등을 말하며 오른쪽의 값을 왼쪽에 대입하거나 연산 후 대입한다.
- 삼항 연산자
  : (조건식) ? A : B를 말하며 조건이 TRUE이면 A를 산출, FALSE면 B를 산출한다.

--------------------------------------------------
chaper 04 조건문과 반복문
--------------------------------------------------

04-1 조건문: if문, switch문

4가지 키워드로 끝내는 핵심 포인트
- if문
  : if(조건식) { ··· }을 말하며 조건식이 true가 되면 중괄호 내부를 실행한다.
- if-else문
  : if(조건식) { ··· } else if(조건식2) { ··· } else { ··· }를 말하며
    조건식1이 true가 되면 if 중괄호 내부를 실행하고, 조건식2가 true가 되면 else if 중괄호 내부를 실행.
    조건식1과 조건식2가 모두 false가 되면 else 중괄호 내부가 실행된다.
- switch문
  : switch(변수) { case 값1 : ··· case 값2 : ··· default: ··· }를 말하며
    변수의 값이 값1이면 첫 번쨰 case 코드를 실행하고, 값2이면 두 번쨰 case 코드를 실행한다.
    값1과 값2가 모두 아니면 default 코드를 실행한다.

--------------------------------------------------

04-2 반복문: for문, while문, do-while문

for문은 반복 횟수를 알고 있을 때 주로 사용하고,
while문은 조건에 따라 반복할 때 주로 사용된다.

5가지 키워드로 끝내는 핵심 포인트
- for문
  : for( 초기화식; 조건식; 증감식 ) { ··· }을 말하며 
    조건식이 true가 될 떄까지만 중괄호 내부를 반복한다. 반복할 때마다 증감식이 실행된다.
    초기화식은 조건식과 증감식에서 사용할 루프 카운터 변수를 초기화한다.
    주로 지정된 횟수만큼 반복할 때 사용한다.
- while문
  : while( 조건식 ) { ··· }을 말하며 조건식이 true 가 될 떄까지만 중괄호 내부를 반복실행.
- do-while문
  : do { ··· } while (조건식);을 말하며 먼저 do 중괄호 내부를 실행하고 그 다음 조건식이
    true가 되면 다시 중괄호 내부를 반복 실행한다.
- break문
  : for문, while문, do-while문 내부에서 실행되면 반복을 취소한다.
- continue문
  : for문, while문, do-while문 내부에서 실행되면 증감식 또는 조건식으로 돌아간다.

--------------------------------------------------
chapter 05 참조 타입
--------------------------------------------------

05-1 참조 타입과 참조 변수

6가지 키워드로 끝내는 핵심 포인트
- 기본 타입
  : byte, short, char, int, long, float, double, boolean 타입을 말하며 이들 타입의 변수에는 값 자체가 저장된다.
- 참조 타입
  : 기본 타입을 제외한 배열, 열거, 클래스, 인터페이스 등을 말한다.
    참조 타입의 변수에는 객체의 번지가 저장된다.
    번지로 객체를 참조한다는 의미에서 참조타입이라고 한다.
- 메모리 사용 영역
  : JVM은 운영체제에서 할당받은 메모리 영역을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용한다.
    메소드 영역에는 정적 필드, 상수, 메소드 코드, 생성자 코드가 위치하며, 힙 영역에는 객체가 생성된다.
    그리고 스택 영역에는 변수가 생성된다.
- 번지 비교
  : 비교 연산자(==, !=)가 기본 타입에에서 사용되면 값을 비교하지만,
    참조 타입에서 사용되면 번지를 비교한다. ==이 true가 나오면 같은 객체를 참조한다는 뜻이고
    false가 나오면 다른 객체를 참조한다는 뜻이다.
- null
  : 참조 타입 변수는 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다.
    null 값도 초기값으로 사용할 수 있기 떄문에 null로 초기화된 참조 변수는 스택 영역에 생성된다.
- NullPointerException
  : 참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 참조 변수를 통해 객체를 사용할 수 없다.
    만약 null인 참조 변수를 통해 있지도 않은 객체의 필드나 메소드를 사용하면 NullPointerException이 발생한다.

--------------------------------------------------

05-2 배열

7가지 키워드로 끝내는 핵심 포인트
- 배열
  : 같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조
- 인덱스
  : 배열 항목에 붙인 번호를 말한다. 0부터 시작하며 0~(배열길이-1)까지의 범위를 갖는다.
- 배열 선언
  : 변수 선언과 비슷한데, 대괄호가 추가되어 타입[] 변수; 형태로 선언된다.
    int[] scores는 int 배열을 선언한다. 여기서 scores는 배열 변수라고 부른다.
- 배열 생성
  : 배열을 생성하는 방법은 2가지.
    하나는 { 값1. 값2. 값3, ·· } 처럼 값 목록으로 생성하는 방법
    다른 하나는 new 타입[길이];로 생성하는 방법이 있다.
- 배열 길이
  : 배열에 저장될 수 있는 항목(값)의 수를 말한다. 배열의 length 필드에 저장되어 있기 떄문에
    변수.length로 배열 길이를 읽을 수 있다.
- 다차원 배열
  : 배열 항목(값)이 또 다른 배열을 참조할 때 이것을 다차원 배열이라고 한다.
    다차원 배열의 선언과 생성 방법은 타입[][] 변수 = new 타입[길이1][길이2]; 이다.
    변수.length는 1차우너 배열의 길이1이 되고,
    변수[인덱스].length는 해당 항목이 참조하는 2차원 배열의 길이2를 말한다.
- 향상된 for문
  : for(타이 변수 : 배열) { ··· }을 말한다.
    향상된 for문은 반복 실행을 위해 루프 카운터 변수와 증감식을 사용하지 않는다.
    배열의 항목 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
    반복할 때마다 변수에는 배열에서 가져온 항목이 저장된다.

--------------------------------------------------

05-3 열거타입

4가지 키워드로 끝내느 핵심 포인트
- 열거타입
  : 열거 타입은 몇 가지로 제한된 상수를 가지는 타입을 말한다.
- 열거 타입 선언
  : enum 타입 { 상수, 상수 ··· } 형태로 열거 타입을 선어한다.
    예를 들어 enum Week { MONDAY, ··· , SUNDAY } 형태를 가진다.
- 열거 상수
  : 열거 타입 선언 떄 주어진 상수를 말하며 타입.상수 형태로 사용한다.
    예를 들어 Week 열거 타입의 상수 MONDAY는 Week.MONDAY로 사용한다.
- 열거 타입 변수
  : 열거 타입으로 선언된 변수를 말한다. 열거 타입 변수에는 열거 상수 중 하나가 대입된다.
    예를 들어 Week today = Week.FRIDAY;에서 today가 열거 타입 변수이다.

--------------------------------------------------
 chapter 06 클래스
--------------------------------------------------

06-1 객체 지향 프로그래밍

객체 간의 관계
예시)
1) 상속 관계
  : 상위(부모) 객체를 기바능로 하위(자식)객체르 생성하는 관계
	- 기계와 자동차는 상속관계
2) 사용 관계
  : 객체 간의 상호작용을 의미
	- 사람과 자동차는 사용관계
3) 집합 관계
  : 객체는 하나의 부품이고, 하나는 완성품에 해당한다.
	- 부품과 자동차는 집합관계

클래스 용도.
	1) 라이브러리 2) 실행용

클래스의 구성 멤버
	1) 필드(Field)
		: 객체의 데이터가 저장되는 곳
	2) 생성자(Constructor)
		: 객체 생성 시 초기화 역할 담당
		: new 연산자로 호출되는 특별한 중괄호 { } 블록.
	3) 메소드(Method)
		: 객체의 동작에 해당하는 중괄호 { } 블록
		: 객체 간의 데이터를 전달하는 수단

6가지 키워드로 끝내는 핵심 포인트
- 클래스
  : 객체를 만들기 위한 설계도
- 객체
  : 클래스로부터 생성되며 'new 클래스()'로 생성한다.
- new 연산자
  : 객체 생성 연산자이며, 생성자를 호출하고 객체 생성 번지를 리턴한다.
- 클래스 변수
  : 클래스로 선언한 변수를 말하며 해당 클래스의 객체 번지가 저장된다.
- 인스턴스
  : 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.
    객체는 클래스의 인스턴스이다.
- 클래스 맴버
  : 클래스에 선언되는 맴버는 필드, 생성자, 메소드가 있다.

--------------------------------------------------

06-2 필드

필드(field)는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태를 저장하는 곳이다.
초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정된다.
필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말한다.

2가지 키워드로 끝내느 핵심 포인트
- 필드 선언
  : 클래스 중괄호 { } 블록 어디서든 선언하거나, 생성자와 메소드 내부에서는 선언할 수 없다.
- 필드 사용
  : 클래스 내부의 생성자와 메소드에서 바로 사용이 가능하나,
    클래스 외부에서 사용할 경우에는 반드시 객체를 생성하고 참조 변수를 통해 사용해야 한다.

--------------------------------------------------

06-3 생성자

6가지 키워드로 끝내는 핵심 포인트
- 기본 생성자
  : 클래스 선언 시 컴파일러에 의해 자동으로 추가되는 생성자이다.
- 생성자 선언
  : 클래스로부터 객체를 생성할 때 호출되는 생성자를 명시적으로 선언할 수 있다.
- 매개 변수
  : 생성자 호출 시 값을 전달받기 위해 선언되는 변수를 말한다.
- 객체 초기화
  : 객체를 사용하기 전에 준비하는 과정으로 필드를 선언할 때 초기화하거나 생성자 내부에서
    필드값을 초기화할 수 있으며, 메소드를 호출하는 내용으로 구성된다.
- 오버로딩
  : 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.
- this()
  : 객체 자신의 또 다른 생성자를 호출할 때 사용한다.

--------------------------------------------------

06-4 메소드

return문 이후의 실행문은 반복문 아닌이상 실행되지 않는다.

클래스 외부에서 메소드를 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤
참조 변수를 이요해서 메소드를 호출해야 한다.

6가지 키워드로 끝내는 핵심 포인트
- 선언부
  : 메소드 선언부는 리턴 타입, 메소드 이름, 매개 변수 선언 부분을 말한다.
- void
  : 리턴값이 없는 메소드는 리턴 타입으로 void를 기술해야 한다.
- 매개 변수
  : 메소드 호출 시 제공되는 매개값은 메소드 선언부의 매개 변수에 차례대로 대입되어,
    메소드 블록 실행 시 이용된다.
- 리턴문
  : 메소드 선언부에 리턴 타입이 있다면 리턴값을 지정하기 위해 return 문이 반드시 있어야 한다.
    리턴 타입이 void라면 return문은 필요없지만,
    메소드 실행 종료를 위해 사용할 수도 있다.
- 호출
  : 메소드를 실행하려면 '메소드 이름(매개값, ...)'형태로 호출해야 한다.
- 오버로딩
  : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(overloading)이라고 한다.
    메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다는 점이다.

--------------------------------------------------

06-5 인스턴스 멤버와 정적 멤버

클래스로부터 객체(인스턴스)는 여러 개가 만들어질 수 있다.
클래스 멤버를 인스턴스 멤버와 정적 멤버로 구분해서 선언할 수 있다.
인스턴스 멤버는 객체마다 가지고 있는 멤버를 말하고,
정적멤버는 클래스에 위치시키고 객체들이 공유하는 멤버.

인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드.

this - 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우 사용.

final - 실행 도중에 수정할 수 없는 것.
  : 초기값을 주는 방법은. 1) 필드 선언시 2) 생성자에서 주는 방법

7가지 키워드로 끝내는 핵심 포인트

- 인스턴스 멤버
  : 인스턴스(instance)멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데,
    이들은 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.
- this
  : 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.
    예를 들어 this.model은 자신이 가지고 있는 model 필드라는 뜻이다.
    this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우,
    인스턴스 멤버인 필드임을 명시하고자 할 떄 사용된다.
- 정적 멤버
  : 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
    이들은 각각 정적 필드, 정적 메소드라고 부른다.
- static
  : 정적 멤버를 선언할 떄 사용되는 키워드이다. 정적 필드, 정적 메소드가 있다.
  : 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.
- 싱글톤(Singleton)
  : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다.
    단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 한다.
  : 외부 호출을 막기 위해 생성자 앞에 private를 붙여준다.
  : 외부에서 객체르 얻는 유일한 방법은 getInstance() 메소드를 호출하는 것이다.
- 상수
  : 수학에서 사용되는 원주율 파이나 지구의 무게 및 둘레 같은 값을 저장하는 필드를
    자바에서는 상수(Constrant)라고 한다.
  : 상수 final static키워드로 선언된다.
  : 대문자로 작성하는 것이 관례

--------------------------------------------------

06-6 패키지와 접근 제한자

4가지 키워드로 끝내는 핵심 포인트
- 패키지 선언
  : 해당 클래스 또는 인터페이스가 어떤 패키지에 속할 것인지를 선언하는 것을 패키지 선언이라고 한다.
  : 소스파일의 최상단에 위치하며 다음과 같이 작성한다.
	package 상위 패키지.하위패키지;
- import 문
  : 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면,
    import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려줘야 한다.
- 접근 제한자
  : 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있다.
    그리고 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나
    필드나 메소드를 사용하지 못하도록 막아야 되는 경우가 있다.
    이때 접근 제한자를 사용할 수 있다.
  : 종류
  - public : 모든 외부 클래스에서 접근 허용
  - protected : 자식 클래스에서 접근 허용
  - default : 같은 패키지에 소속된 클래스만 접근 허용
  - private : 모든 외부 클래스에서 접근 불가
- Getter/Setter
  : 필드는 외부에서 접근할 수 없도록 막고
    메소드는 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도한다.
    필드의 값을 외부로 리턴해주는 메소드를 Getter라고 하고
    외부에서 값을 받아 필드를 변경하는 메소드를 Setter라고 한다.

--------------------------------------------------
chapter 07 상속
--------------------------------------------------

07-1 상속

4가지 키워드로 끝내는 핵심 포인트
- 상속
  : 부모 클래스의 필드와 메소드를 자식 클래스에서 사용할 수 있도록 한다.
  : 표기는 exteds 뒤에 기술한다.
  : class 자식클래스 exteds 부모 클래스
- 메소드 재정의(오버라이딩:Overridng)
  : 부모 메소드를 자식 클래스에서 다시 정의하는 것을 말한다.
  : @Override 이노테이션은 메소드가 정확하게 재정의 된지 컴파일러가 확인해 준다.
- final 클래스
  : final 키워드로 선언된 클래스는 부모 클래스로 사용할 수 없는 final 클래스이다.
  : 같은 의미로 자식 클래스를 만들 수 없다.
  : ex) public final class 클래스 { ··· }
- final 메소드
  : final 키워드로 선언된 메소드는 자식 클래스에서 재정의할 수 없는 final 메소드이다.

--------------------------------------------------

07-2 타입 변환과 다양성

다형성
  : 사용 방법은 동일하지만 다양한 객체를 이용해서 다양한 실행결과가 나오도록 하는 성질.

5가지 키워드로 끝내는 핵심 포인트
- 클래스 타입 변환
  : 다른 클래스 타입으로 객체를 대입하는 것을 말한다.
- 자동 타입 변환
  : 자식 객체를 부모 타입 변수에 대입할 때에는 자동으로 타입이 전환된다.
- 강제 타입 변환
  : 자식 객체가 부모 타입으로 변환된 상태에서 다시 원래의 자식 타입으로 변환 하고자 할 때
    캐스팅() 연산자를 사용해서 강제 타입 변환할 수 있다.
- instanceof 연산자
  : 객체가 어떤 타입인지 조사할 때 instanceof 연산자를 사용한다.
    주로 강제 타입 변환 전에 변환이 가능한지 조사할 때 사용한다.
- 다형성
  : 객체 사용 방법은 동일하지만 실행결과가 다양하게 나오는 성질을 말한다.
    다형성을 구현하는 기술은 메소드 재정의와 타입 변환이다.
    자식 객체가 재정의된 메소드를 가지고 있을 경우,
    부모 타입으로 자동 타입 변환 후에 메소드를 호출하면
    재정의된 자식 메소드가 호출되면서 다양한 실행결과를 가져올 수 있다.

--------------------------------------------------

07-3 추상 클래스

2가지 키워드로 끝내는 핵심 포인트
- 추상 클래스
  : 클래스들의 공통적인 필드와 메소드를 추출해서 선언한 클래스를 말한다.
- 추상 메소드
  : 추상 클래스에서만 선언할 수 있고, 메소드의 선언부만 있는 메소드를 말한다.
    추상 메소드는 자식 클래스에서 재정의되어 실행 내용을 결정해야 한다.

--------------------------------------------------
chapter08 인터페이스
--------------------------------------------------

08-1 인터페이스

5가지 키워드로 끝내는 핵심 포인트
- 인터페이스
  : 객체의 상요 방법을 정의한 타입이며 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
- 상수 필드
  : 인터페이스의 상수 필드는 기본적으로 public static final 특성을 갖는다.
    관례적으로 필드 이름은 모두 대문자로 작성해야 하며, 선언 시 초기값을 대입해야 한다.
- 추상 메소드
  : 인터페이스에 선언된 메소드는 public abstrat가 생략되고
    메소드 선언부만 있는 추상 메소드이다. 구현 클래스는 반드시 추상 메소드를 재정의해야 한다.
- implements
  : 구현 클래스는 어떤 인터페이스로 사용 가능한지(어떤 인터페이스를 구현하고 있는지)를 기술하기 위해
    클래스 선언 시 implements 키워드를 사용한다.
- 인터페이스 사용
  : 클래스를 선언할 때 인터페이스 필드, 생성자 또는 메소드의 매개 변수,
    생성자 또는 메소드의 로컬 변수로 선언될 수 있다.
  1)인터페이스가 필드 타입으로 사용될 경우
   : 필드에 구현 객체를 대입할 수 있다.
  2) 인터페이스가 생성자의 매개 변수 타입으로 사용될 경우
   : new 연산자로 객체를 생성할 떄 구현 객체를 생성자의 매개값으로 대입할 수 있다.
  3) 인터페이스가 로컬 변수 타입으로 사용될 경우
   : 변수에 구현 객체를 대입할 수 있다.
  4) 인터페이스가 메소드의 매개 변수 타입으로 사용될 경우
   : 메소드 호출 시 구현 객체를 매개값으로 대입할 수 있다.

--------------------------------------------------

08-2 타입 변환과 다형성

5가지 키워드로 끝내는 핵심 포인트
- 자동 타입 변환
  : 구현 객체가 인터페이스 변수에 대입되는 것을 말한다.
- 다형성
  : 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를
    만드는 기술이라는 개념상의 차이는 있지만 둘 다 다형성을 구현하는 방법은 비슷하다.
    모두 재정의와 타입 변환 기능을 제공하기 떄문이다.
- 강제 타입 변환
  : 인터페이스에 대입된 구현 객체를 다시 원래 구현 클래스 타입으로 변환하는 것을 말한다.
- instanceof
  : 강제 타입 변환을 하기 전에 변환이 가능한지 조사할 때 사용한다.
    상속에서는 자식 클래스 타입인지, 인터페이스에서는 구현 클래스 타입인지를 확인할 때 사용한다.
- 인터페이스 상속
  : 클래스는 다중 상속을 허용하지 않지만, 인터페이스는 다중 상속을 허용한다.
    즉 extends 키워드 뒤에 상위 인터페이스가 올 수 있다.

--------------------------------------------------
chapter 09 중첩 클래스와 중첩 인터페이스
--------------------------------------------------

09-1 중첩 클래스와 중첩 인터페이스 소개

4가지로 끝내는 핵심 포인트
- 중첩 클래스
  : 클래스 내부에 선언한 클래스를 말한다.
    중첩 클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있고,
    외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.
- 멤버 클래스
  : 클래스의 멤버로서 선언되는 중첩 클래스를 말한다.
    멤버 클래스는 바깥 객체의 필요 여부에 따라 인스턴스 멤버 클래스와 정적 멤버 클래스로 구분된다.
- 로컬 클래스
  : 생성자 또는 메소드 블록 내부에 선언된 중첩 클래스를 말한다.
- 중첩 인터페이스
  : 클래스의 멤버로 선언된 인터페이스를 말한다.
    중첩 인터페이스는 인스턴스 멤버 인스턴스와 정적멤버 인터페이스 모두 가능하다.
    주로 정적 멤버 인터페이스를 많이 사용하는데 UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다.

--------------------------------------------------

09-2 익명 객체

2가지 키워드로 끝내는  핵심 포인트
- 익명 자식 객체
  : 자식 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면
    자식 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다.
    이 경우에는 익명 자식 객체를 생성해서 사용하는 것이 좋은 방법이다.

    익명 자식 객체를 생성하는 방법
    부모클래스 [ 필드 | 변수 ] = new 부모클래스(매개값, ···) {
	// 필드
	// 메소드
	};
- 익명 구현 객체
  : 구현 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면
    구현 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다.
    이 경우에는 익명 구현 객체를 생성해서 사용하는 것이 좋은 방법이다.

    익명 구현 객체를 생성하는 방법
    인터페이스 [ 필드 | 구현 ] = new 인터페이스() {
	// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
	// 필드
	// 메소드
	};

--------------------------------------------------
Chapter 10 예외 처리
--------------------------------------------------

10-1 예외 클래스

4가지 키워드로 끝내는 핵심 포인트
- 예외
  : 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류.
    예외가 발생되면 프로그램은 곧바로 종료된다는 점에서 에러와 비슷하다.
    예외는 예외 처리(exception handling)를 통해 프로그램을 종료하지 않고
    정상 실행 상태가 유지되도록 할 수 있다.
- 예외 클래스
  : 자바에서는 예외를 클래스로 관리한다.
    JVM은 프로그램을 실행하는 도중에 예외가 발생하면 해당 예외 클래스로 객체를 생성한다.
    그리고 나서 예외 처리 코드에서 예외 객체를 이용할 수 있도록 해준다.
    모든 예외 클래스는 java.lang.Exception 클래스를 상속받는다.
- 일반 예외
  : 컴파일러 체크 예외라고도 하는데, 프로그램 실행 시 예외가 발생할 가능성이 높기 때문에
    자바 소스를 컴파일하는 과정에서 해당 예외 처리 코드가 있는지 검사한다.
    만약 예외 처리 코드가 없다면 컴파일 에러가 발생한다.
- 실행 예외
  : 컴파일러 넌 체크 예외라고도 하는데,
    실행 시 예측할 수 없어 갑자기 발생하기 떄문에
    컴파일하는 과정에서 예외 처리 코드가 있는지 검사하지 않는다.

--------------------------------------------------

10-2 예외 처리

4가지 키워드로 끝내는 핵심 포인트
- 예외처리
  : 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고,
    정상 실행을 유지할 수 있도록 처리하는 것을 말한다.
  + 일반 예외가 발생할 가능성이 있는 코드를 발견하면 컴파일 에러를 발생시켜
    개발자가 강제적으로 예외처리 코드를 작성하도록 요구한다.
- try-catch-finally 블록
  : 생성자 내부와 메소드 내부에서 작성되어
    일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 도와준다.
  + 예시
	try { 예외 발생 가능 코드
	} catch(예외 클래스 e) {
	예외처리
	} finally {
	항상 실행;
	}
- 다중 catch 블록
  : catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다.
    그 이유는 try 블록에서 동시다발적으로 예외가 발생하지 않고,
    하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch 블록으로 이동하기 때문이다.
  + catch(Exception e) 는 맨 마지막에 적어야 한다.
- throws 키워드
  : 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할.
    throws 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해서 나열해주면 된다.

--------------------------------------------------
chapter 11 기본 API 클래스
--------------------------------------------------

11-1 java.lang 패키지

java.lang 패키지는 자바 프로그램의 기본적인 클래스를담고 있는 패키지이다.
그래서 java.lang 패키지에 있는 클래스와 인터페이스는 import 없이 사용할 수 있다.

API 도큐먼트는 아래 주소에서 확인 가능하다.
docs.oracle.com/en/java/javase/index.html

6가지 키워드로 끝내는 핵심 포인트
- Object 클래스
  : 자바의 최상위 부모 클래스이다.
    따라서 Object 클래스의 메소드는 모든 자바 객체에서 사용할 수 있다.

	- 객체 비교 : equeals()
	- 객체 해시코드 : hashCode())
	  : 객채를 식별하는 하나의 정수값이다.
	- 객체 문자 정보 : toString()
	  : 클래스이름@16진수해시코드로 구성된 문자 정보를 리턴한다.

- System 클래스
  : System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있다.
    즉 프로그램 종료, 키보드로부터 입력, 모니터로 출력, 현재 시간 읽기 등이 가능하다.
    System클래스의 모든 필드와 메소드는 정적 필드와 정적 메소드로 구성되어 있다.

	- 프로그램 종료 : exit()
	  : 현재 실행하고 있는 프로세스를 강제 종료시키는 역할을 한다.
	- 현재 시각 읽기 CurrentTimeMillis(), nanoTime()
  	  : 컴퓨터의 시계로부터 현재 시간을 읽어서
    	    밀리세컨드(1/1000초)와 나노세컨드(1/10^9초) 단위의 long 값을 리턴한다.

- Class 클래스
  : 자바는 클래스와 인터페이스의 메타 데이터를 Class 클래스로 관리한다.
    메타 데이터란 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보를 말한다.

	- Class 객체 얻기 getClass(), forName()

- String 클래스
  : 문자열 리터럴은 String 객체로 자동 생성되지만,
    String 클래스의 다양한 생성자를 이용해서 직접 String 객체를 생성할 수도 있다.
    String 객체는 문자열 조작을 위한 많은 메소드를 가지고 있다.

	- charAt()
	  : 매개값으로 주어진 인덱스의 문자를 리턴한다.
	- 문자열 비교 : equeals()
	  : 문자열의 == 연산자는 각각 지정된 번지를 비교하고 equals()는 값을 비교한다.
	- 바이트 배열로 변환 : getBytes()
	  : 시스템의 기본 문자셋으로 인코딩된 바이트 배열로 리턴한다.
	- 문자열 찾기 : indexOf()
	  : 매개값으로 주어진 문자열이 시작되는 인덱스를 리턴한다.
	- 문자열 길이 : length()
	  : 문자열의 길이(문자의 수)를 리턴한다.
	- 문자열 대치 : replace()
	  : 첫 번째 매개값인 문자열을 찾아 두 번째 매개값인 문자열로 대치해
	    "새로운"문자열을 생성하고 리턴한다.
	- 문자열 잘라내기 : subString()
	  : 주어진 인덱스에서 문자열을 추철한다.
	    시작과 끝, 주어진 인덱스부터 끝까지 문자열을 추출할 수 있다.
	- 알파벳 소 · 대문자 변경 : toLowerCase(), toUpperCase()
	  + equalsIgnoreCase()메소드를 사용하면 대소문자 구분없이 값을 비교할 수 있다.
	- 문자열 앞뒤 공백 잘라내기 : trim()
	  : 문자열의 앞뒤 공백을 제거한 "새로운" 문자열을 생성하고 리턴한다.
	    단, 중간의 공백은 제거하지 않는다.
	- 문자열 변환 : valueOf()
	  : 기본 타입의 값을 문자열로 변환하는 기능을 가지고 있다.

- Wrapper(포장) 클래스
  : 기본 타입의 값을 갖는 객체를 포장 객체라고 한다.
    포장 객체는 외부에서 변경할 수 없다.
    기본 타입의 값을 포장 객체로 만드는 것을 박싱이라고 하고,
    반대로 포장 객체로부터 기본 타입의 값을 얻는 것을 언박싱이라고 한다.

- Math 클래스
  : 수학 계산에 사용할 수 있는 메소드를 제공하며,
    Math 클래스가 제공하는 메소드는 정적 메소드이므로 Math 클래스로 바로 사용할 수 있다.

--------------------------------------------------

11-2 java.util 패키지

2가지 키워드로 끝내는 핵심 포인트
- Date 클래스
  : 날짜를 표현하는 클래스입니다. Date 클래스는 객체 간에 날짜 정보를 주고받을 때
    매개 변수나 리턴 타입으로 주로 사용한다.
	- 원하는 날짜 형식 : java.text 패키지의 SimpleDateFormat 클래스와 함께 사용하는 것이 좋다.

- Calendar 클래스
  : 달력을 표현하는 클래스이다.
    Calendar 클래스는 추상abstract 클래스이므로 new 연산자를 사용해서 인스턴스를 생성할 수 없다.
    Calendar 클래스 정적 메소드인 getInstance() 메소드를 이용하면
    현재 운영체제에 설정되어 있는 시간대TimeZone를 기준으로 한 Calendar 하위 객체를 얻을 수 있다.

--------------------------------------------------
chapter 12 스레드

12-1 멀티 스레드

5가지 키워드로 끝내는 핵심 포인트
- 프로세스
  : 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당 받아
    애플리케이션이 실행되는데, 이것으 프로세스라고 한다.
- 멀티 스레드
  : 하나의 프로세스 내에 동시 실행을 하는 스레드들이 2개 이상인 경우를 말한다.
- 메인 스레드
  : 자바의 모든 애플리케이션은 메인 스레드가 main() 메소드를 실행하면서 시작한다.
    메인 스레드는 main() 메소드의 첫 코드부터 아래로 순차적을 실행하고,
    main()메소드의 마지막 코드를 실행하거나 return문을 만나면 실행이 종료된다.
- 작업 스레드
  : 메인 작업 이외에 병렬 작업의 수만큼 생성하는 스레드를 말한다.
    작업 스레드도 객체로 생성되기 떄문에 클래스가 필요하다.
    Thread 클래스를 직접 객체화해서 생성할수도 있고,
    Thread 클래스를 상속해서 하위 클래스를 만들어 생성할 수도 있다.
	+ ex)
	Runnable task = new Task();
	Thread thread = new Thread(task);

- 동기화 메소드
  : 멀티 스레드 프로그램에 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계영역(Critical Section) 이라고 한다.
    자바는 임계 영역을 지정하기 위해 동기화(Synchronized)메소드를 제공한다.
    스레드가 객체 내부의 동기화 메소드를 실행하면
    즉시 객체에 잠금을 걸어 다른 스레드가 동기화 메소드를 실행하지 못하도록 한다.

--------------------------------------------------

12-2 스레드 제어

4가지 키워드로 끝내는 핵심 포인트
- 스레드 상태
  : 스레드를 생성하고 시작하면 스레드는 다양한 상태를 가지게 된다.
    스레드의 상태는 자동으로 변경될 수도 있고, 코드에 의해서 변경될 수도 있다.
- 일시 정지
  : 실행 중인 스레드를 일정 시간 멈추게 하고 싶다면 Thread 클래스의 정적 메소드인 sleep()을 사용하면 된다.
    다음과 같이 Thread.sleep(시간)메소드를 호출한 스레드는 주어진 시간동안 일시 정지 상태가 되고
    다시 실행 대기 상태로 돌아간다.
	+ try{} cathc() {}문을 함께 사용해야한다.
- 안전한 종료
  : Thread는 스레드를 즉시 종료하기 위해서 stop() 메소드를 제공하고 있는데,
    이 메소드는 deprecated(중요도가 떨어져 이제 사용하지 않음)되었다.
    그 이유는 stop()메소드로 스레드를 갑자기 종료하게 되면
    스레드가 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문이다.
    스레드를 안전하게 종료하기 위해서 stop플래그를 이용하거나 interrupt()메소드를 이용하는 방법이 있다.
- 데몬 스레드
  : 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드이다.
    주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료되는데, 주 스레드의 보조 역할을 수행하므로
    주 스레드가 종료되면 데몬 스레드의 존재 의미가 사라지기 떄문이다.
	- 사용 예시 thread.setDeamon(true);
--------------------------------------------------
chapter 13 컬렉션 프레임워크
--------------------------------------------------

13-1 컬렉션 프레임워크

컬렉션은 객체의 저장을 뜻하고 ,프레임워크란 사용 방법을 정해놓은 라이브러리를 말한다.
컬렉션 프레임워크의 주요 인터페이스로는 LIst, Set, Mep이 있다.

List 컬렉션
  : 배열과 비슷하게 객체를 인덱스로 관리한다.


	ArrayList
	: List 인터페이스의 대표적인 구현 클래스.


4가지 키워드로 끝내는 핵심 포인트
- 컬렉션 프레임워크
  : 널리 알려져 있는 자료구조(Data Structrure)를 사용해서
    객체드을 효율적으로 추가, 삭제, 검색할 수 있도록
    인터페이스와 구현 클래스들을 java.util패키지에서 제공한다.
    이들을 총칭해서 컬렉션 프레임워크(Collection Framework)라고 부른다.
- List 컬렉션
  : List 컬렉션은 배열과 비슷하게 객체를 인덱스로 관리한다.
    배열과 차이점은 저장 용량(Capacity)이 자동으로 증가하며,
    객체를 저장할 때 자동 인덱스가 부여된다는 것이다.
    추가, 삭제. 검색을 위한 다양한 메소드가 제공된다.
	  - List 컬렉션에 객체를 추가할 때 add() 메소드
	  - 객체를 찾아올 때 get() 메소드
	  - 객체 삭제는 remove() 메소드
    List 컬렉션은 동일한 객체를 중복 저장할 수 있고, null도 저장이 가능하다.
- Set 컬렉션
  : Set 컬렉션은 저장 순서가 유지되지 않는다.
    또한 객체를 중복해서 저장할수 없고, 하나의 null만 저장할 수 있다.
    Set 컬렉션은 수학의 집합과 비슷하다.
    집합은 순서와 상관없고 중복이 허용되지 않기 떄문이다.
- Map 컬렉션
  : Map 컬렉션은 키(key)와 값(Value)으로 구성된 Map.Entry 객체를 저장하는 구조를 가지고 있다.
    Entry는 Map 인터페이스 내부에 선언된 중첩 인터페이스이다.
    여기서 키와 같은 값은 모두 객체이다.
    키는 중복 저장될 수 없지만 값은 주복 저장될 수 있다.
    만약 기존에 저장된 키와 동일한 키로 값을 저장하면
    기존의 값은 없어지고 새로운 값으로 대체된다.

--------------------------------------------------

13-2 LIFO 와 FIFO 컬렉션

2가지 키워드로 끝내는 핵심 포인트
- Stack
  : 후입선출(LIFO)을 구현한 클래스이다
	- push(E item) : 주어진 객체를 스택에 넣는다
	- peek() : 스택의 맨 위 객체를 가져온다. (객체를 스택에서 제거 X )
	- pop() : 스텍의 맨 위 객체를 가져온다. (객체를 스택에서 제거 O )
- Queue
  : 선입선출(FIFO)에 필요한 메소드를 정의한 인터페이스이다.
    구현 클래스로는 LinkedList가 있다.
	- offer(E e) : 주어진 객체를 스택에 넣는다
	- peek() : 객체 하나를 가져온다. (객체를 큐에서 제거 X )
	- pop() : 객체 하나를 가져온다. (객체를 큐에서 제거 O )

--------------------------------------------------
chapter 14 입출력 스트림
--------------------------------------------------

14-1 입출력 스트림

flush() 메소드 : 내부 버퍼에 잔류된 바이트를 모두 출력하는 역할을 한다.
close() 메소드 : 스트림을 닫는 역할을 한다.

5가지 키워드로 끝나는 핵심 포인트
- 입출력 스트림
  : 자바에서 데이터는 스트림을 통해 입출력된다.
    프로그램이 출발지냐 또는 도착지냐에 따라서 사용하는 스트림의 종류가 결정된다.
    프로그램이 도착지이면 흘러온 데이터를 입력받아야 하므로 입력 스트림을 사용한다.
    반대로 프로그램이 출발지면 데이터를 출력해야 하므로 출력 스트림을 사용한다.

	- 바이트 기반 스트림 : 그림, 멀티미디어 등의 바이너리 데이터를 읽고 출력할 때 사용
	- 문자 기반 스트림 : 문자 데이터를 읽고 출력할 떄 사용

- InputStream
  : 바이트 기반 입력 스트림의 최상위 클래스로 추상 클래스이다.
    모든 바이트 기반 입력 스트림은 InputStream 클래스를 상속받아서 만들어진다.
    InputStream 클래스에는 바이트 기반 입력 스트림이
    기본적으로 가져야 할 메소드가 정의되어 있다.

	- read() 메소드
	 : 입력 스트림으로 터 1byte를 읽고 int(4byte) 타입으로 리턴한다.
	- read(byte[] b) 메소드 : 입력 스트림으로부터 매개값을
	 : 주어진 배열의 길이만큼 바이트를 읽고 해당 배열에 저장한다.
	- read(byte[] b, int off, int len) 메소드
	 : 입력 스트림으로부터 len개의 바이트만큼 읽고,
	    매개값으로 주어진 바이트 배열b[off]부터 len개보다 작을 경우에는 읽은 수만큼만 리턴한다.

- OutputStream
  : 바이트 기반 출력 스트림의 최상위 클래스로 추상 클래스이다.
    모든 바이트 기반 출력 스트림 클래스는 OutputStream 클래스를 상속받아서 만들어진다.
    OutputStram 클래스에는 모든 바이트 기반 출력 스트림이
    기본적으로 가져야 할 메소드가 정의되어 있다.

	- Write(int b) 메소드
	 : 매개 변수로 주어지는 int(4byte)에서 끝 1byte만 출력 스트림으로 보낸다.
	- write(byte[] b) 메소드
	 : 매개값으로 주어진 배열의 모든 바이트를 출력 스트림으로 보낸다.

- Reader
  : 문자 기반 입력 스트림의 최상위 클래스로 추상 클래스이다.
    모든 문자 기반 입력 스트림은 Reader 클래스를 상속받아서 만들어진다.
    Reader 클래스에는 문자 기반 입력 스트림이
    기본적으로 가져야 할 메소드가 정의되어 있다.

	- read() 메소드
	 : 입력 스트림으로부터 1개의 문자(2byte)를 읽고 int(4byte) 타입으로 리턴한다.
	- read(char[] cbuf) 메소드
	 : 입력 스트림으로부터 맥개값으로 주어진 문자 배열의 길이만큼 문자를 읽고 배열에 저장한다.
	- read(char[] cbuf, int off, int len) 메소드
	 : 입력 스트림으로부터 len개의 문자만큼 읽고 매개값으로 주어진 문자 배열에서 cbuf[off]부터 len개까지 저장한다.
	

- Writer
  : 문자 기반 출력 스트림의 최상위 클래스로 "추상 클래스"이다.
    모든 문자 기반 출력 스트림 클래스는 Writer 클래스를 상속받아서 만들어진다.
    Writer 클래스는 모든 문자 기반 출려 스트림이 기본적으로 가져야 할 메소드가 정의되어 있다.

	- write(int c) 메소드
	 : 매개 변수로 주어지는 int(4byte)에서 끝 2byte(1개의 문자)만 출력 스트림으로 보내진다.
	- write(char[] cbuf) 메소드
	 : 매개값을 주어진 char[] 배열의 모든 문자를 출력 스트림으로 보낸다.
	- write(char[] cbut, int off, int len) 메소드
	 : c[off]부터 len개의 문자를 출력 스트림으로 보낸다.

--------------------------------------------------

14-2 보조 스트림
- 보조 스트림
  : 다른 스트림과 연결되어 여러 가지 편리한 기능을 제공해주는 스트림을 말한다.
    보조 스트림은 자체적으로 입출력을 수행할 수 업기 때문에 입출력 소스와 바로 연결되는
    InputStream, OutputStream, Reader, Writer 등에 연결해서 입출력을 수행한다.
    보조 스트림은 문자 변환, 입출력 성능 향상, 기타 타입 입출력 등의 기능을 제공한다.
- 문자 변환
  : 소스 스트림이 바이트 기반 스트림 (InputStream, OutputStream, FileInputStream, FileOutputStream) 이면서
    입출력 데이터가 문자라면 Reader와 Writer로 변환해서 사용한느 것을 고려할 수 있다.
    그 이유는 문자 입출력은 Reader와 Writer가 편리하기 때문이다.
    OutputSTreamWriter는 Writer로 변환하는 보조 스트림이고,
    InputStreamReader는 Reader로 변환하는 보조 스트림이다.
- 성능 향상
  : 기본적으로 출력 스트림은 내부에 작은 버퍼를 가지고 있다.
    하지만 이것만으로는 불충분하다.
    보조 스트림 중에서 메모리 버퍼를 추가로 제공하여 프로그램의 실행 성능을 향상시키는 것들이 있다.
    바이트 기반 스트림에서는 BufferedInputStream, BufferedOutputStream이 있고
    문자 기반 스트림에는 BufferedReader, Buffered Writer가 있다.
- 기본 타입 입출력
  : DataInputStream과 DataOutPutStream 보조 스트림을 연결하면 기본 타입인
    boolean, char, short, int , long, float, double을 입출력할 수 있다.
- 개행 출력
  : PrintStream/printWriter의 println() 메소드는 출력할 데이터 끝에 개행 문자인 '\n' 을 추가한다.
    그래서 출력시 콘솔이나 파일에서 줄 바꿈이 일어난다.

--------------------------------------------------

